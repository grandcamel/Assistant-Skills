#!/usr/bin/env python3
"""
Input Validators Template

Placeholders:
- {{API_NAME}} - API name for error messages
- {{ID_PATTERN}} - Regex pattern for IDs (e.g., r"^[a-zA-Z0-9-]+$")
- {{KEY_PATTERN}} - Regex pattern for keys (e.g., r"^[A-Z][A-Z0-9]*-[0-9]+$")
"""

import re
from typing import Any, List, Optional, TypeVar
from urllib.parse import urlparse

from .error_handler import ValidationError

T = TypeVar("T")


def validate_required(value: T, field_name: str) -> T:
    """
    Validate that a value is provided (not None or empty).

    Args:
        value: The value to validate
        field_name: Name of the field (for error message)

    Returns:
        The validated value

    Raises:
        ValidationError: If value is None or empty
    """
    if value is None:
        raise ValidationError(f"{field_name} is required")
    if isinstance(value, str) and not value.strip():
        raise ValidationError(f"{field_name} cannot be empty")
    if isinstance(value, (list, dict)) and len(value) == 0:
        raise ValidationError(f"{field_name} cannot be empty")
    return value


def validate_id(value: str, field_name: str = "ID") -> str:
    """
    Validate an ID format.

    Args:
        value: The ID value
        field_name: Name of the field (for error message)

    Returns:
        The validated ID

    Raises:
        ValidationError: If ID format is invalid
    """
    validate_required(value, field_name)

    # Default pattern: alphanumeric with hyphens/underscores
    pattern = r"^[a-zA-Z0-9_-]+$"

    if not re.match(pattern, value):
        raise ValidationError(
            f"Invalid {field_name} format: '{value}'. "
            f"Must contain only letters, numbers, hyphens, and underscores."
        )

    return value


def validate_key(value: str, field_name: str = "Key") -> str:
    """
    Validate a key format (e.g., PROJECT-123).

    Args:
        value: The key value
        field_name: Name of the field (for error message)

    Returns:
        The validated key (uppercase)

    Raises:
        ValidationError: If key format is invalid
    """
    validate_required(value, field_name)

    # Normalize to uppercase
    value = value.upper()

    # Pattern for keys like "PROJ-123"
    pattern = r"^[A-Z][A-Z0-9]*-[0-9]+$"

    if not re.match(pattern, value):
        raise ValidationError(
            f"Invalid {field_name} format: '{value}'. "
            f"Expected format: PROJECT-123 (letters, hyphen, numbers)."
        )

    return value


def validate_url(value: str, field_name: str = "URL", require_https: bool = True) -> str:
    """
    Validate a URL format.

    Args:
        value: The URL value
        field_name: Name of the field (for error message)
        require_https: If True, only HTTPS URLs are allowed

    Returns:
        The validated URL (without trailing slash)

    Raises:
        ValidationError: If URL format is invalid
    """
    validate_required(value, field_name)

    try:
        parsed = urlparse(value)

        if not parsed.scheme:
            raise ValidationError(f"Invalid {field_name}: missing scheme (http/https)")

        if require_https and parsed.scheme != "https":
            raise ValidationError(f"Invalid {field_name}: must use HTTPS")

        if not parsed.netloc:
            raise ValidationError(f"Invalid {field_name}: missing domain")

        # Return normalized URL
        return value.rstrip("/")

    except Exception as e:
        if isinstance(e, ValidationError):
            raise
        raise ValidationError(f"Invalid {field_name}: {e}")


def validate_email(value: str, field_name: str = "Email") -> str:
    """
    Validate an email address format.

    Args:
        value: The email value
        field_name: Name of the field (for error message)

    Returns:
        The validated email (lowercase)

    Raises:
        ValidationError: If email format is invalid
    """
    validate_required(value, field_name)

    # Simple email pattern
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"

    if not re.match(pattern, value):
        raise ValidationError(f"Invalid {field_name} format: '{value}'")

    return value.lower()


def validate_choice(
    value: str,
    choices: List[str],
    field_name: str = "Value",
    case_sensitive: bool = False,
) -> str:
    """
    Validate that a value is one of the allowed choices.

    Args:
        value: The value to validate
        choices: List of allowed values
        field_name: Name of the field (for error message)
        case_sensitive: If False, comparison is case-insensitive

    Returns:
        The validated value (matching case of choice if case-insensitive)

    Raises:
        ValidationError: If value is not in choices
    """
    validate_required(value, field_name)

    if case_sensitive:
        if value in choices:
            return value
    else:
        value_lower = value.lower()
        for choice in choices:
            if choice.lower() == value_lower:
                return choice

    raise ValidationError(
        f"Invalid {field_name}: '{value}'. Must be one of: {', '.join(choices)}"
    )


def validate_positive_int(
    value: Any,
    field_name: str = "Value",
    allow_zero: bool = False,
) -> int:
    """
    Validate that a value is a positive integer.

    Args:
        value: The value to validate
        field_name: Name of the field (for error message)
        allow_zero: If True, zero is allowed

    Returns:
        The validated integer

    Raises:
        ValidationError: If value is not a positive integer
    """
    try:
        int_value = int(value)
    except (TypeError, ValueError):
        raise ValidationError(f"{field_name} must be an integer")

    if allow_zero:
        if int_value < 0:
            raise ValidationError(f"{field_name} must be zero or positive")
    else:
        if int_value <= 0:
            raise ValidationError(f"{field_name} must be a positive integer")

    return int_value


def validate_list(
    value: Any,
    field_name: str = "Value",
    min_length: int = 0,
    max_length: Optional[int] = None,
) -> List:
    """
    Validate that a value is a list with optional length constraints.

    Args:
        value: The value to validate
        field_name: Name of the field (for error message)
        min_length: Minimum list length
        max_length: Maximum list length (None for no limit)

    Returns:
        The validated list

    Raises:
        ValidationError: If value is not a valid list
    """
    if not isinstance(value, list):
        raise ValidationError(f"{field_name} must be a list")

    if len(value) < min_length:
        raise ValidationError(f"{field_name} must have at least {min_length} items")

    if max_length is not None and len(value) > max_length:
        raise ValidationError(f"{field_name} must have at most {max_length} items")

    return value


def validate_string_length(
    value: str,
    field_name: str = "Value",
    min_length: int = 0,
    max_length: Optional[int] = None,
) -> str:
    """
    Validate string length constraints.

    Args:
        value: The string to validate
        field_name: Name of the field (for error message)
        min_length: Minimum string length
        max_length: Maximum string length (None for no limit)

    Returns:
        The validated string

    Raises:
        ValidationError: If string length is out of bounds
    """
    validate_required(value, field_name)

    if len(value) < min_length:
        raise ValidationError(
            f"{field_name} must be at least {min_length} characters"
        )

    if max_length is not None and len(value) > max_length:
        raise ValidationError(
            f"{field_name} must be at most {max_length} characters"
        )

    return value
